<!-- TITLE: M121 -->
<!-- SUBTITLE: M121 Aggregation -->

# Reference Database
`mongo "mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017/aggregations?replicaSet=Cluster0-shard-0" --authenticationDatabase admin --ssl -u m121 -p aggregations --norc`

Aggregattoin quick reference: https://docs.mongodb.com/manual/meta/aggregation-quick-reference/
# pipelines
Data is processed in a composition of stages, to filter and transform. Called pipleines, after the UNIX pipe. Run on the server not the client (driver).

```
db.userColl.agreegate([
	{ < stage 1 > },
	{ < stage 1 > },
	...
], options)
```

# Operators
`$match`, `$group` and `$project` are aggreation operators;. they must appear as the start of each stage.

`$gte` and `$in` are query operators.

# Expressions
Expressions are a lot like functions; they always appear in a "value" position. They provide additional document properties. Expressions may take a single argument or an array of arguments.

e.g. (where `<gravityOnEarth>` and `<weightOnEarth>` are fixed values. :
```
	myWeight: { $multiply: [$divide: [ "$gravity.value", <gravityOnEarth>], <weightOnEarth>] } }
```

# Variables
`$` prefixed names are field paths in the documents presented to that stage; that includes any new fields added by previous stages from expressions.

There are a few system variables and they are always in uppercase, e.g. `$$CURRENT` (current document).

And finally there are user varaibles, having a `$$` prefix too (for convention, do not use uppercase user variables).
 
 
 # $match (filter)
 https://docs.mongodb.com/manual/reference/operator/aggregation/match/
 
 Some come as early in stages as possible, and can be repeated many times in a single aggregation. Uses the standard MongoDB query syntax.
 
 Cannot use the `$where` operator.
 
 If using `$text` operator, then it must be the first stage in the piepline.
 
 # $project
 `$project` operator is much more powerful than that available i n the `find` operator. As an aggregation operator, `$project` can return expressions, which can create new fields. Should be used aggresively to keep document set as small as possible. Can be used in as many stages are required.
 
 "object.paths" must be withon quotes. If assigning an "object.path" to another document property, must prefix "$" on the right hand side of the assignment:
 ```
 {
	 $project: {
		 _id:0,
		 gravity: "$gravity.value",
		 myWeight: { $multiply: [$divide: [ "$gravity.value", 9.8], 72] } }
	 }
 }
 ```

  # $addFields
	Similar to `$project` in that it can add addtiional fields to the document; but it can only add fields, unlike project which can _rename_ and _show/hide_. But it is the _show/hide_ aspect of `$project`, which as soon as you project a calculated field, you have to add other fields you need in the document.
	
```
aggregate([
	{
		$addFields: {
			gravity: "$gravity.value",
			myWeight: { $multiply: [$divide: [ "$gravity.value", 9.8], 72] } },
		}
	}
]);
```

Works well combining both `$project` and `$addFields`.

# $geoNear
`$geoNear` must be the first stage in a pipeline. `$geoNear` can be used on shared collections, whereas `$near` (prior to V4.0) could not be used on shared collections: https://docs.mongodb.com/manual/reference/operator/query/near/.

Both (`$goeNear` and `$near`) sort the documents. But unlike $near, `$geoNear` as an aggregration pipeline can then have subsequent transformations and sorting applied (unlike `$near`).

Restriction to uising `$geoNear` is that each document must have just one geo index.

`$geoNear`, in addition to `min`/`max`/`limit`/`num` filtering (note limit and num are idenitical in restricting the number of results), but `$geoNear` has the `query` property to which takes a find query to pre filter on documents. This reduces the resultset, which is important given `$geoNear` must be the first stage in a pipeline (so before `$match`).
 # Exercises
 ## $match:
 
 ```
 
db.movies.aggregate([
	{
		$match: {
			"imdb.rating": { $gte: 7 },
			"rated": { $in: ["PG", "G"] },
			"languages": { $all: ["English", "Japanese"] },
			"genres": { $nin: ["Crime", "Horror"] },
		}
	}
]).itcount();



var pipeline = [
	{
		$match: {
			"imdb.rating": { $gte: 7 },
			"rated": { $in: ["PG", "G"] },
			"languages": { $all: ["English", "Japanese"] },
			"genres": { $nin: ["Crime", "Horror"] },
		}
	}
];
```

## $project with expressions
Counting number of words in the movie title and returning those with only one word in the title:
```
db.movies.aggregate([
	{
		$project: {
			_id: 0,
			title: 1,
			titleSplit: { $split: [ "$title", " "]},
		}
	},
	{
		$project: {
			title: 1,
			titleSplit: 1,
			numberOfWords: { $cond: { if: { $isArray: "$titleSplit" }, then: { $size: "$titleSplit" }, else: 1} },
		}
	},
	{
		$match: {
			numberOfWords: 1
		}
	}
]);
```

Mapping writers having `<name (role>)` format to just `<name>`:

```
db.movies.aggregate([
	{
		$match: { writers: { $exists: true } },
	},
	{
		$project: { writers: 1, cast: 1, _id:0 },
	},
	{
		$project: {
			oldWriters: "$writers",
			writers: {
				$map : {
					input: "$writers",
					as: "thisWriter",
					in: {
						$arrayElemAt: [
							{ $split: [ "$$thisWriter", " (" ] },
							0
						]
					}
				}
			},
		},
	}
])
```

Returning data as:
```
{ "oldWriters" : [ "Nils Krok (play)", "Victor Sj�str�m" ], "writers" : [ "Nils Krok", "Victor Sj�str�m" ] }
{ "oldWriters" : [ "Charles Tait" ], "writers" : [ "Charles Tait" ] }
{ "oldWriters" : [ "Mary Shelley (novel)", "J. Searle Dawley" ], "writers" : [ "Mary Shelley", "J. Searle Dawley" ] }
{ "oldWriters" : [ "Urban Gad" ], "writers" : [ "Urban Gad" ] }
{ "oldWriters" : [ "Victorien Sardou (adapted from the play by)" ], "writers" : [ "Victorien Sardou" ] }
{ "oldWriters" : [ "Georges M�li�s" ], "writers" : [ "Georges M�li�s" ] }
{ "oldWriters" : [ "Georges M�li�s" ], "writers" : [ "Georges M�li�s" ] }
{ "oldWriters" : [ "Mrs. Hepworth (story)" ], "writers" : [ "Mrs. Hepworth" ] }
{ "oldWriters" : [ "Charles Perrault (story)" ], "writers" : [ "Charles Perrault" ] }
{ "oldWriters" : [ "Georges M�li�s" ], "writers" : [ "Georges M�li�s" ] }
{ "oldWriters" : [ "L. Frank Baum (novel)", "Otis Turner (scenario)" ], "writers" : [ "L. Frank Baum", "Otis Turner" ] }
{ "oldWriters" : [ "Georges M�li�s (screenplay)", "Georges M�li�s (story)", "Jules Verne (novel)" ], "writers" : [ "Georges M�li�s", "Georges M�li�s", "Jules Verne" ] }
{ "oldWriters" : [ "Georges M�li�s" ], "writers" : [ "Georges M�li�s" ] }
{ "oldWriters" : [ "George L. Du Maurier (novel)" ], "writers" : [ "George L. Du Maurier" ] }
{ "oldWriters" : [ "Winsor McCay (comic strip)" ], "writers" : [ "Winsor McCay" ] }
{ "oldWriters" : [ "Lewis Carroll (novel)", "Cecil M. Hepworth" ], "writers" : [ "Lewis Carroll", "Cecil M. Hepworth" ] }
{ "oldWriters" : [ "Marcel Allain (novel)", "Louis Feuillade", "Pierre Souvestre (novel)" ], "writers" : [ "Marcel Allain", "Louis Feuillade", "Pierre Souvestre" ] }
{ "oldWriters" : [ "Georges M�li�s", "Jules Verne (play)", "Adolphe d'Ennery (play)" ], "writers" : [ "Georges M�li�s", "Jules Verne", "Adolphe d'Ennery" ] }
{ "oldWriters" : [ "Lionel Barrymore" ], "writers" : [ "Lionel Barrymore" ] }
{ "oldWriters" : [ "James Keane", "William Shakespeare (play)" ], "writers" : [ "James Keane", "William Shakespeare" ] }
```


Labour of Love (optional extra lab)  - returning the number of document the same person appears in the directors, cast and writers sets - uses `setIntersection` expression within `project`:
```
db.movies.aggregate([
  {
      $match: {
      writers: { $exists: true },
      cast: { $exists: true },
      directors: { $exists: true },
    },
  },
  {
    $project: {
      _id: 0,
      cast: 1, directors: 1,
      writers: {
          $map : {
              input: "$writers",
              as: "thisWriter",
              in: {
                  $arrayElemAt: [
                      { $split: [ "$$thisWriter", " (" ] },
                      0
                  ]
              }
          }
      },
    },
  },
  {
    $project: {
      labourOflove: {
        $size: {
          $setIntersection: [
            "$writers",
            "$directors",
            "$cast",
          ]  
        }
      }
    }
  },
  {
    $match: {
      labourOflove: { $gt: 0 }
    }
  }
]).itcount()
```
