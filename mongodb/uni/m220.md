<!-- TITLE: MongoDB Uni M220 -->
<!-- SUBTITLE: M220JS - BUilding a node.js mflix application with MongoDB -->

# MongoDB
## Arrays
Arrays in documents are first class citizens. In MongoDB, `find({ "countries" : "UK"})` will match all documents where the "UK" is one of the `countries` array elements.

If wanting to match on multiple array elements:
* `find({"countries" : { $all : ["UK", "USA"]}})` - will match those documents where countries is "UK" and "USA" only.
* `find({"countries" : { $in : ["UK", "USA"]}})` - will match those documents where countries is either "UK" and/or "USA" only.

## Aggregations
Pipeline stages:
* blocking - e.g. sort
* streaming - e.g. match

# node.js
## Callback, Promise, async/await
Traditional Javascript callbacks can be passed into MongoDB APIs:
```
const insertMany = () => {
	const callback = () => { console.log("Done") };
	
	// Get the documents collection
	db.collection('documents').insertMany(
			[ {a : 1}, {a : 2}, {a : 3} ],
			function(err, result) {
				console.log("Inserted 3 documents into the collection", result);
				callback(result);
			}
	);
}
```

More atypical now that they simply retrun a Promise if no callback is given:
```
const insertMany = () => {
	const collection = db.collection('documents').insertMany([ {a : 1}, {a : 2}, {a : 3} ]);

	collection
		.then(result => {
				console.log("Inserted 3 documents into the collection", result);
		})
		.catch(err => {
			console.error(err);
		});
	}
```

That promise can of course be used in async/await approach:
```
const insertMany = async () => {
	try {
		const result = await db.collection('documents').insertMany([ {a : 1}, {a : 2}, {a : 3} ]);
	
	} catch (err) {
		console.error(err);
	}
}
```

## Recordsets
`findOne` returns a document or null.
`find` returns a cursor, upon which you can call `toArray` to return set of documents.


```
  static async getMoviesByCountry(searchCountries) {
    /**
    Ticket: Projection

    Write a query that matches movies with the countries in the "countries"
    list, but only returns the title and _id of each movie.

    Remember that in MongoDB, the $in operator can be used with a list to
    match one or more values of a specific field.
    */

    let cursor
    try {
      // TODO Ticket: Projection
      // Find movies matching the "countries" list, but only return the title
      // and _id. Do not put a limit in your own implementation, the limit
      // here is only included to avoid sending 46000 documents down the
      // wire.
      cursor = await movies
        .find(
          {
            countries : { $in : searchCountries}
          },
          {
            projection: {
              title: 1,
            }
          }
        )
    } catch (e) {
      console.error(`Unable to issue find command, ${e}`)
      return []
    }

    return cursor.toArray()
  }
	```
	
	Against a cursor, common methods can be invoked including:
	1. limit
	2. sort
	3. skip (only relevant when sorting)

This is equivalent (but not the same as) to stages in the aggregation pipeline, because when called upon the cursor, the action is being performed with the driver not the database (aggregration runs on the server).
	
